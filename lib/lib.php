<?php

use \Firebase\JWT\JWT;

require_once __DIR__ . '/jwt.lib.php';

if (!isset($dirRoot)) {
    $dirRoot = '';
}

class AppConfig
{
    var $appId = '';
    var $appUid = '';
    var $secretKey = '';
    var $appBaseUrl = '';

    var $moyskladVendorApiEndpointUrl = 'https://apps-api.moysklad.ru/api/vendor/1.0';
    var $moyskladJsonApiEndpointUrl = 'https://api.moysklad.ru/api/remap/1.2';

    public function __construct(array $cfg)
    {
        foreach ($cfg as $k => $v) {
            $this->$k = $v;
        }
    }
}

$cfg = new AppConfig(require('config.php'));

function cfg(): AppConfig
{
    return $GLOBALS['cfg'];
}

//
//  Vendor API 1.0
//

class VendorApi
{

    function context(string $contextKey)
    {
        return $this->request('POST', '/context/' . $contextKey);
    }

    function updateAppStatus(string $appId, string $accountId, string $status)
    {
        return $this->request('PUT',
            "/apps/$appId/$accountId/status",
            "{\"status\": \"$status\"}");
    }

    function updateAppKey(string $appId, string $accountId, string $key)
    {
        return $this->request('PUT',
            "/apps/$appId/$accountId/status",
            "{\"status\": \"$status\"}");
    }

    private function request(string $method, $path, $body = null)
    {
        return makeHttpRequest(
            $method,
            cfg()->moyskladVendorApiEndpointUrl . $path,
            buildJWT(),
            $body);
    }
}

function makeHttpRequest(string $method, string $url, string $bearerToken, $data = null) {
    $curl = curl_init($url);

    $headers = array('Authorization: Bearer ' . $bearerToken, 'Accept-Encoding: gzip');
    if ($data) {
        $headers[] = 'Content-type: application/json';
    }
    log_message('DEBUG', "Request: $method $url" .print_r($headers, true) . print_r($data, true));

    $options = [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_FOLLOWLOCATION => true,
        CURLOPT_MAXREDIRS => 10,
        CURLOPT_TIMEOUT => 30,
        CURLOPT_HTTPHEADER => $headers,
        CURLOPT_CUSTOMREQUEST => $method,
        CURLOPT_ENCODING => '',
        CURLOPT_HEADER => true
    ];

    if ($method !== 'GET' && $data !== null) {
        $options[CURLOPT_POSTFIELDS] = is_array($data)
            ? http_build_query($data)
            : $data;
    }

    curl_setopt_array($curl, $options);

    $response = curl_exec($curl);
    $error = curl_error($curl);
    $info = curl_getinfo($curl);
    curl_close($curl);

    if ($error) {
        log_message('ERROR', "Response error: $error");
        return null;
    } else {
        $headerSize = $info['header_size'];
        $body = substr($response, $headerSize);
        log_message('DEBUG', "Response: $method $url\n$response");
        return json_decode($body);
    }
}

$vendorApi = new VendorApi();

function vendorApi(): VendorApi
{
    return $GLOBALS['vendorApi'];
}

function buildJWT()
{
    $token = array(
        "sub" => cfg()->appUid,
        "iat" => time(),
        "exp" => time() + 300,
        "jti" => bin2hex(random_bytes(32))
    );
    return JWT::encode($token, cfg()->secretKey);
}

//
//  JSON API 1.2
//

class JsonApi
{

    private $accessToken;

    function __construct(string $accessToken)
    {
        $this->accessToken = $accessToken;
    }

    function stores()
    {
        return makeHttpRequest(
            'GET',
            cfg()->moyskladJsonApiEndpointUrl . '/entity/store',
            $this->accessToken);
    }

    function getObject($entity, $objectId)
    {
        return makeHttpRequest(
            'GET',
            cfg()->moyskladJsonApiEndpointUrl . "/entity/$entity/$objectId",
            $this->accessToken);
    }
    

    function getObjects($entity)
    {
        return makeHttpRequest(
            'GET',
            cfg()->moyskladJsonApiEndpointUrl . "/entity/$entity",
            $this->accessToken);
    }

    function getMetadata($name)
    {
        return makeHttpRequest(
            'GET',
            cfg()->moyskladJsonApiEndpointUrl . "/entity/" . $name . "/metadata",
            $this->accessToken,
            json_encode([
                'url' => '',
                'action' => 'UPDATE',
                'entityType' => 'customorder'
                . ''
            ]));
    }
    
    function getWebhooks()
    {
        return $this->getObjects('webhook');
    }
    
    function createWebhook($url, $action, $entityType )
    {
        $data = [
            'url' => $url,
            'action' => $action,
            'entityType' => $entityType,
        ];

        return makeHttpRequest(
            'POST',
            cfg()->moyskladJsonApiEndpointUrl . '/entity/webhook',
            $this->accessToken,
            json_encode($data));
    }

    public function deleteWebhook($webhook)
    {
        $data = [
            'url' => $webhook->url,
            'action' => $webhook->action,
            'entityType' => $webhook->entityType,
        ];

        return makeHttpRequest(
            'DELETE',
            cfg()->moyskladJsonApiEndpointUrl . '/entity/webhook/' . $webhook->id,
            $this->accessToken);
    }
}

function jsonApi(): JsonApi
{
    if (empty($GLOBALS['jsonApi'])) {
        $accessToken = AppInstance::get()->accessToken;
        
        if ($accessToken) {
            $GLOBALS['jsonApi'] = new JsonApi($accessToken);
        }
    }
    return $GLOBALS['jsonApi'];
}

//
//  Logging
//

const LOG_LEVELS = [
    'DEBUG' => 1,
    'INFO' => 2,
    'WARN' => 3,
    'ERROR' => 4
];

function log_message($level, $message)
{
    if (LOG_LEVELS[$level] >= LOG_LEVELS[LOG_LEVEL]) {

        $log_entry = sprintf(
            "[%s][%s] %s\n",
            date('Y-m-d H:i:s'),
            $level,
            $message
        );

        $vendorLog = getenv('VENDOR_LOG');

        if (!empty($vendorLog)) {
            file_put_contents($vendorLog, $log_entry, FILE_APPEND);
        }
    }
}

//
//  AppInstance state
//

$currentAppInstance = null;

class AppInstance
{

    const UNKNOWN = 0;
    const SETTINGS_REQUIRED = 1;
    const ACTIVATED = 100;

    var $appId;
    var $accountId;
    var $infoMessage;
    var $store;
    
    var $login;
    var $password;
    var $shopId;
    var $email;
    var $address;
    var $additional;

    var $accessToken;

    var $fiscal;
    
    var $document;
    var $action;
    var $type;
    var $method;
    var $newStatus;
    var $inn;
    var $sno;
    var $obj;
    
    var $status = AppInstance::UNKNOWN;

    static function get(): AppInstance
    {
        $app = $GLOBALS['currentAppInstance'];
        if (!$app) {
            throw new InvalidArgumentException("There is no current app instance context");
        }
        return $app;
    }

    public function __construct($appId, $accountId)
    {
        $this->appId = $appId;
        $this->accountId = $accountId;
    }

    function getStatusName()
    {
        switch ($this->status) {
            case self::SETTINGS_REQUIRED:
                return 'SettingsRequired';
            case self::ACTIVATED:
                return 'Activated';
        }
        return null;
    }

    function persist()
    {
        @mkdir('data');
        file_put_contents($this->filename(), serialize($this));
    }

    function delete()
    {
        @unlink($this->filename());
    }

    private function filename()
    {
        return self::buildFilename($this->appId, $this->accountId);
    }

    private static function buildFilename($appId, $accountId)
    {
        return $GLOBALS['dirRoot'] . getenv('DATA_DIR') . "/$appId.$accountId.app";
    }

    static function loadApp($accountId): AppInstance
    {
        return self::load(cfg()->appId, $accountId);
    }

    static function load($appId, $accountId): AppInstance
    {
        $data = @file_get_contents(self::buildFilename($appId, $accountId));
        if ($data === false) {
            $app = new AppInstance($appId, $accountId);
        } else {
            $app = unserialize($data);
        }
        $GLOBALS['currentAppInstance'] = $app;
        return $app;
    }

}
